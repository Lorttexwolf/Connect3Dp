// <auto-generated/>
#nullable enable

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using PartialBuilderSourceGen.Attributes;
using PartialBuilderSourceGen.Extensions;
using PartialBuilderSourceGen.Types;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace PartialBuilderSourceGen
{
	[Generator]
	public sealed class PartialBuilderSourceGen : IIncrementalGenerator
	{
		public void Initialize(IncrementalGeneratorInitializationContext context)
		{
			var types = context.SyntaxProvider.ForAttributeWithMetadataName(
				typeof(GeneratePartialBuilderAttribute).FullName!,
				static (n, _) => n is ClassDeclarationSyntax or StructDeclarationSyntax or RecordDeclarationSyntax,
				static (ctx, _) => (INamedTypeSymbol)ctx.TargetSymbol);

			context.RegisterSourceOutput(types, static (ctx, type) =>
			{
				var t = new ClassOrStructureToUse(type);

				ctx.AddSource($"{type.Name}.Changes.g.cs",
					ChangesStructEmitter.Emit(t));

				ctx.AddSource($"{type.Name}.Updater.g.cs",
					UpdateEmitter.Emit(t));
			});
		}
	}

	internal static class ChangesStructEmitter
	{
		public static string Emit(ClassOrStructureToUse t)
		{
			var ns = t.Base.ContainingNamespace.IsGlobalNamespace
				? null
				: t.Base.ContainingNamespace.ToDisplayString();

			var sb = new StringBuilder();

			sb.AppendLine("#nullable enable");
			if (ns != null)
			{
				sb.AppendLine($"namespace {ns};");
				sb.AppendLine();
			}

			// Keep Changes as a readonly positional record struct (immutable)
			sb.AppendLine($"{t.Base.DeclaredAccessibility.ToString().ToLower()} readonly record struct {t.ChangesName}(");

			for (int i = 0; i < t.Properties.Count(); i++)
			{
				var p = t.Properties[i];

				if (p.Type.TryIfDictionary(out var k, out var v))
				{
					// Order: Added, Removed, Updated (matches usage)
					sb.AppendLine($"\tKeyValuePair<{k}, {v}>[] {p.Base.Name}Added,");
					sb.AppendLine($"\t{k}[] {p.Base.Name}Removed,");
					sb.Append($"\tKeyValuePair<{k}, {v}>[] {p.Base.Name}Updated");
				}
				else if (p.Type.TryIfSet(out var s))
				{
					sb.AppendLine($"\t{s}[] {p.Base.Name}Added,");
					sb.Append($"\t{s}[] {p.Base.Name}Removed");
				}
				else
				{
					sb.AppendLine($"\tbool {p.Base.Name}HasChanged,");
					sb.Append($"\t{p.Type} {p.Base.Name}Previous");
				}

				sb.AppendLine(i == t.Properties.Count() - 1 ? "" : ",");
			}

			sb.AppendLine(")");
			sb.AppendLine("{");

			// Build HasChanged expression: OR of all checks
			var checks = new List<string>();
			foreach (var p in t.Properties)
			{
				if (p.Type.TryIfDictionary(out _, out _))
				{
					checks.Add($"{p.Base.Name}Added.Length != 0");
					checks.Add($"{p.Base.Name}Removed.Length != 0");
					checks.Add($"{p.Base.Name}Updated.Length != 0");
				}
				else if (p.Type.TryIfSet(out _))
				{
					checks.Add($"{p.Base.Name}Added.Length != 0");
					checks.Add($"{p.Base.Name}Removed.Length != 0");
				}
				else
				{
					checks.Add($"{p.Base.Name}HasChanged");
				}
			}

			var expr = checks.Count == 0 ? "false" : string.Join(" || ", checks.Distinct());
			sb.AppendLine($"    public bool HasChanged => {expr};");

			sb.AppendLine();
			sb.AppendLine($$"""
				public override string ToString()
				{
					if (!HasChanged) return $"{nameof({{t.ChangesName}})}";
					var parts = new List<string>();
			""");

			foreach (var p in t.Properties)
			{
				if (p.Type.TryIfDictionary(out var k, out var v))
				{
					sb.AppendLine($$"""
							if ({{p.Base.Name}}Added.Length != 0)
								parts.Add($"{{p.Base.Name}}Added = [{(string.Join(", ", {{p.Base.Name}}Added.Select(e => e.ToString())))}]");

							if ({{p.Base.Name}}Removed.Length != 0)
								parts.Add($"{{p.Base.Name}}Removed = [{(string.Join(", ", {{p.Base.Name}}Removed.Select(e => e.ToString())))}]");

							if ({{p.Base.Name}}Updated.Length != 0)
								parts.Add($"{{p.Base.Name}}Updated = [{(string.Join(", ", {{p.Base.Name}}Updated.Select(e => e.ToString())))}]");
					""");
				}
				else if (p.Type.TryIfSet(out var s))
				{
					sb.AppendLine($$"""
							if ({{p.Base.Name}}Added.Length != 0)
								parts.Add($"{{p.Base.Name}}Added = [{(string.Join(", ", {{p.Base.Name}}Added.Select(e => e.ToString())))}]");

							if ({{p.Base.Name}}Removed.Length != 0)
								parts.Add($"{{p.Base.Name}}Removed = [{(string.Join(", ", {{p.Base.Name}}Removed.Select(e => e.ToString())))}]");
					""");
				}
				else
				{
					sb.AppendLine($$"""
							if ({{p.Base.Name}}HasChanged) 
								parts.Add($"{{p.Base.Name}} = Previous: {{{p.Base.Name}}Previous}");
					""");
				}
			}

			sb.AppendLine($$"""
					return $"{{t.ChangesName}} {(string.Join(", ", parts))}";
				}
			""");


			sb.AppendLine("}");

			return sb.ToString();
		}
	}

	internal static class UpdateEmitter
	{
		public static string Emit(ClassOrStructureToUse t)
		{
			var ns = t.Base.ContainingNamespace.IsGlobalNamespace
				? null
				: t.Base.ContainingNamespace.ToDisplayString();

			var sb = new StringBuilder();

			sb.AppendLine("#nullable enable");
			if (ns != null)
			{
				sb.AppendLine($"namespace {ns};");
				sb.AppendLine();
			}

			EmitUpdaterType(sb, t);
			return sb.ToString();
		}

		private static void EmitUpdaterType(StringBuilder sb, ClassOrStructureToUse t)
		{
			sb.AppendLine($"{t.Base.DeclaredAccessibility.ToString().ToLower()} {(t.IsStruct ? "struct" : "sealed class")} {t.UpdaterName}");
			sb.AppendLine("{");

			// Backing fields
			foreach (var p in t.Properties)
				EmitBacking(sb, p);

			sb.AppendLine();

			// Methods (Set/Update/Remove/Unset)
			foreach (var p in t.Properties)
				EmitMethods(sb, p, t);

			// TryCreate (object initializer)
			EmitTryCreate(sb, t);

			// Changes(...) method (returns new Changes(...) - immutable)
			EmitChangesMethod(sb, t);

			// AppendUpdate / WithUpdate (call Changes(...) and apply)
			EmitApplyMethod(sb, t);

			sb.AppendLine("}");
		}

		private static void EmitBacking(StringBuilder sb, PropertyToUse p)
		{
			if (p.Type.TryIfDictionary(out var k, out var v))
			{
				if (v.TryIfUpdater(out var u))
					sb.AppendLine($"    public Dictionary<{k},{u.UpdaterName}>? {p.Base.Name}ToSet {{ get; private set; }}");
				else
					sb.AppendLine($"    public Dictionary<{k},{v}>? {p.Base.Name}ToSet {{ get; private set; }}");

				sb.AppendLine($"    public HashSet<{k}>? {p.Base.Name}ToRemove {{ get; private set; }}");
				return;
			}

			if (p.Type.TryIfSet(out var s))
			{
				if (s.TryIfUpdater(out var su))
					sb.AppendLine($"    public HashSet<{su.UpdaterName}>? {p.Base.Name}Updates {{ get; private set; }}");
				else
				{
					sb.AppendLine($"    public HashSet<{s}>? {p.Base.Name}ToSet {{ get; private set; }}");
					sb.AppendLine($"    public HashSet<{s}>? {p.Base.Name}ToRemove {{ get; private set; }}");
				}
				return;
			}

			if (p.Type.TryIfUpdater(out var u2))
				sb.AppendLine($"    public {u2.UpdaterName}? {p.Base.Name} {{ get; private set; }}");
			else
				sb.AppendLine($"    public {p.Type} {p.Base.Name} {{ get; private set; }}");

			sb.AppendLine($"    public bool {p.Base.Name}IsSet {{ get; private set; }}");
		}

		private static void EmitMethods(StringBuilder sb, PropertyToUse p, ClassOrStructureToUse t)
		{
			// DICTIONARY
			if (p.Type.TryIfDictionary(out var k, out var v))
			{
				if (v.TryIfUpdater(out var vu))
				{
					sb.AppendLine($$"""
					public {{t.UpdaterName}} Update{{p.Base.Name}}({{k}} key, Action<{{vu.UpdaterName}}> configure)
					{
						{{p.Base.Name}}ToSet ??= new Dictionary<{{k}}, {{vu.UpdaterName}}>();
						if (!{{p.Base.Name}}ToSet.TryGetValue(key, out var u))
						{
							u = new {{vu.UpdaterName}}();
							{{(vu.DictKeyProp != null ? $"u.Set{vu.DictKeyProp.Base.Name}(key);" : "")}}
							{{p.Base.Name}}ToSet[key] = u;
						}
						configure(u);
						return this;
					}
					""");
				}
				else
				{
					sb.AppendLine($$"""
					public {{t.UpdaterName}} Set{{p.Base.Name}}({{k}} key, {{v}} val)
					{
						{{p.Base.Name}}ToSet ??= new Dictionary<{{k}}, {{v}}>();
						{{p.Base.Name}}ToSet[key] = val;
						return this;
					}

					public {{t.UpdaterName}} Remove{{p.Base.Name}}({{k}} key)
					{
						{{p.Base.Name}}ToRemove ??= new HashSet<{{k}}>();
						{{p.Base.Name}}ToRemove.Add(key);
						return this;
					}
					""");
				}

				// Unset helper for dictionary
				sb.AppendLine($$"""
				public {{t.UpdaterName}} Unset{{p.Base.Name}}()
				{
					{{p.Base.Name}}ToSet = null;
					{{p.Base.Name}}ToRemove = null;
					return this;
				}
				""");

				return;
			}

			// SET
			if (p.Type.TryIfSet(out var s))
			{
				if (s.TryIfUpdater(out var su))
				{
					sb.AppendLine($$"""
					public {{t.UpdaterName}} Update{{p.Base.Name}}(Action<{{su.UpdaterName}}> configure)
					{
						{{p.Base.Name}}Updates ??= new HashSet<{{su.UpdaterName}}>();
						var u = new {{su.UpdaterName}}();
						configure(u);
						{{p.Base.Name}}Updates.Add(u);
						return this;
					}
					""");
				}
				else
				{
					var pn = p.Base.Name.Substring(0, 1).ToLowerInvariant() + p.Base.Name.Substring(1);
					sb.AppendLine($$"""
					public {{t.UpdaterName}} Set{{p.Base.Name}}({{s}} {{pn}})
					{
						{{p.Base.Name}}ToSet ??= new HashSet<{{s}}>();
						{{p.Base.Name}}ToSet.Add({{pn}});
						return this;
					}

					public {{t.UpdaterName}} Remove{{p.Base.Name}}({{s}} {{pn}})
					{
						{{p.Base.Name}}ToRemove ??= new HashSet<{{s}}>();
						{{p.Base.Name}}ToRemove.Add({{pn}});
						return this;
					}
					""");
				}

				// Unset helper for set
				sb.AppendLine($$"""
				public {{t.UpdaterName}} Unset{{p.Base.Name}}()
				{
					{{p.Base.Name}}ToSet = null;
					{{p.Base.Name}}ToRemove = null;
					return this;
				}
				""");

				return;
			}

			// REGULAR
			if (p.Type.TryIfUpdater(out var u))
			{
				if (p.Type.IsValue)
				{
					sb.AppendLine($$"""
					public {{t.UpdaterName}} Update{{p.Base.Name}}(Func<{{u.UpdaterName}}, {{u.UpdaterName}}> configure)
					{
						{{p.Base.Name}}IsSet = true;
						{{p.Base.Name}} ??= new {{u.UpdaterName}}();
						{{p.Base.Name}} = configure({{p.Base.Name}}.Value);
						return this;
					}
					""");
				}
				else
				{
					sb.AppendLine($$"""
					public {{t.UpdaterName}} Update{{p.Base.Name}}(Action<{{u.UpdaterName}}> configure)
					{
						{{p.Base.Name}}IsSet = true;
						{{p.Base.Name}} ??= new {{u.UpdaterName}}();
						configure({{p.Base.Name}});
						return this;
					}

					""");
				}

					sb.AppendLine($$"""
				public {{t.UpdaterName}} Remove{{p.Base.Name}}()
				{
					{{p.Base.Name}}IsSet = true;
					{{p.Base.Name}} = null;
					return this;
				}
				""");

				// Unset helper for nested-updater property
				sb.AppendLine($$"""
				public {{t.UpdaterName}} Unset{{p.Base.Name}}()
				{
					{{p.Base.Name}}IsSet = false;
					{{p.Base.Name}} = null;
					return this;
				}
				""");
			}
			else
			{
				sb.AppendLine($$"""
				public {{t.UpdaterName}} Set{{p.Base.Name}}({{p.Type}} value)
				{
					{{p.Base.Name}}IsSet = true;
					{{p.Base.Name}} = value;
					return this;
				}

				public {{t.UpdaterName}} Remove{{p.Base.Name}}()
				{
					{{p.Base.Name}}IsSet = true;
					{{p.Base.Name}} = default;
					return this;
				}
				""");

				// Unset helper
				sb.AppendLine($$"""
				public {{t.UpdaterName}} Unset{{p.Base.Name}}()
				{
					{{p.Base.Name}}IsSet = false;
					{{p.Base.Name}} = default;
					return this;
				}
				""");
			}
		}

		private static void EmitTryCreate(StringBuilder sb, ClassOrStructureToUse t)
		{
			if (t.IsStruct)
			{
				sb.AppendLine($"    public bool TryCreate(out {t.Base.Name} outResult)");
			}
			else
			{
				sb.AppendLine($"    public bool TryCreate(out {t.Base.Name}? outResult)");
			}

			sb.AppendLine("    {");
			sb.AppendLine($"		outResult = {(t.IsStruct ? "default" : "null")};");

			// Validate required properties
			foreach (var p in t.Properties.Where(p => p.IsRequiredToCreate && !p.Type.IsDictionary && !p.Type.IsSet))
			{
				if (p.Type.TryIfUpdater(out _))
				{
					if (p.Type.IsValue)
					{
						//if (p.IsRequiredToCreate)
						//{

						//}

						sb.AppendLine($"        if (!{p.Base.Name}IsSet || !{p.Base.Name}.Value.TryCreate(out var c{p.Base.Name})) return false;");
					}
					else
					{
						sb.AppendLine($"        if (!{p.Base.Name}IsSet || !{p.Base.Name}.TryCreate(out var c{p.Base.Name})) return false;");
					}
				}
				else
				{
					sb.AppendLine($"        if (!{p.Base.Name}IsSet) return false;");
				}
			}

			// Build initializer assignment list (works with init-only props)
			var initializerEntries = new List<string>();
			foreach (var p in t.Properties.Where(p => p.IsRequiredToCreate && !p.Type.IsDictionary && !p.Type.IsSet)) // TODO: Support TryCreate Dicts and Sets
			{
				if (p.Type.TryIfUpdater(out _))
					initializerEntries.Add($"{p.Base.Name} = c{p.Base.Name}");
				else
					initializerEntries.Add($"{p.Base.Name} = this.{p.Base.Name}");
			}

			// Emit creation using object initializer
			if (initializerEntries.Count == 0)
			{
				sb.AppendLine($"        var result = new {t.Base.Name}();");
			}
			else
			{
				var joined = string.Join(", ", initializerEntries);
				sb.AppendLine($"        var result = new {t.Base.Name}() {{ {joined} }};");
			}

			// Apply remaining updates
			if (t.IsStruct && t.Base.IsReadOnly)
				sb.AppendLine($"        result = WithUpdate(result, out _);");
			else if (t.IsStruct)
				sb.AppendLine($"        AppendUpdate(ref result, out _);");
			else
				sb.AppendLine($"        AppendUpdate(result, out _);");

			sb.AppendLine("		outResult = result;");

			sb.AppendLine();
			sb.AppendLine("        return true;");
			sb.AppendLine("    }");
		}

		private static void EmitChangesMethod(StringBuilder sb, ClassOrStructureToUse t)
		{
			var type = t.Base;
			var name = char.ToLowerInvariant(type.Name[0]) + type.Name.Substring(1);
			var changesName = t.ChangesName;

			// signature
			if (type.IsValueType)
				sb.AppendLine($"    public {changesName} Changes(in {type.Name} {name})");
			else
				sb.AppendLine($"    public {changesName} Changes({type.Name} {name})");

			sb.AppendLine("    {");

			var ctorArgs = new List<string>();

			foreach (var p in t.Properties)
			{
				// DICTIONARY
				if (p.Type.TryIfDictionary(out var dictKeyType, out var dictValueType))
				{
					var addedVar = $"a{p.Base.Name}_added";
					var updatedVar = $"u{p.Base.Name}_updated";
					var removedVar = $"r{p.Base.Name}_removed";

					sb.AppendLine($"\t\tvar {addedVar} = new List<KeyValuePair<{dictKeyType}, {dictValueType}>>();");
					sb.AppendLine($"\t\tvar {updatedVar} = new List<KeyValuePair<{dictKeyType}, {dictValueType}>>();");
					sb.AppendLine($"\t\tvar {removedVar} = new List<{dictKeyType}>();");

					// ToSet
					sb.AppendLine($"\t\tif (this.{p.Base.Name}ToSet != null)");
					sb.AppendLine("\t\t{");
					sb.AppendLine($"\t\t\tforeach (var kv in this.{p.Base.Name}ToSet)");
					sb.AppendLine("\t\t\t{");

					if (dictValueType.TryIfUpdater(out var dictValUpdater))
					{
						// assert key
						if (dictValUpdater.DictKeyProp is not null)
							sb.AppendLine($"\t\t\t\tkv.Value.Set{dictValUpdater.DictKeyProp.Base.Name}(kv.Key);");

						sb.AppendLine($"\t\t\t\tif (kv.Value.TryCreate(out var created))");
						sb.AppendLine("\t\t\t\t{");
						sb.AppendLine($"\t\t\t\t\tif ({name}.{p.Base.Name} != null && {name}.{p.Base.Name}.TryGetValue(kv.Key, out var existing))");
						sb.AppendLine($"\t\t\t\t\t\t{updatedVar}.Add(new KeyValuePair<{dictKeyType}, {dictValueType}>(kv.Key, created));");
						sb.AppendLine("\t\t\t\t\telse");
						sb.AppendLine($"\t\t\t\t\t\t{addedVar}.Add(new KeyValuePair<{dictKeyType}, {dictValueType}>(kv.Key, created));");
						sb.AppendLine("\t\t\t\t}");
					}
					else
					{
						sb.AppendLine($"\t\t\t\tif ({name}.{p.Base.Name} != null && {name}.{p.Base.Name}.ContainsKey(kv.Key))");
						sb.AppendLine($"\t\t\t\t\t{updatedVar}.Add(kv);");
						sb.AppendLine("\t\t\t\telse");
						sb.AppendLine($"\t\t\t\t\t{addedVar}.Add(kv);");
					}

					sb.AppendLine("\t\t\t}");
					sb.AppendLine("\t\t}");

					// Removals
					sb.AppendLine($"\t\tif (this.{p.Base.Name}ToRemove != null && {name}.{p.Base.Name} != null)");
					sb.AppendLine("\t\t{");
					sb.AppendLine($"\t\t\tforeach (var k in this.{p.Base.Name}ToRemove)");
					sb.AppendLine("\t\t\t{");
					sb.AppendLine($"\t\t\t\tif ({name}.{p.Base.Name}.ContainsKey(k)) {removedVar}.Add(k);");
					sb.AppendLine("\t\t\t}");
					sb.AppendLine("\t\t}");

					// Construct arrays local names
					var addedArr = $"{addedVar}.ToArray()";
					var removedArr = $"{removedVar}.ToArray()";
					var updatedArr = $"{updatedVar}.ToArray()";

					ctorArgs.Add(addedArr);
					ctorArgs.Add(removedArr);
					ctorArgs.Add(updatedArr);

					sb.AppendLine();
					continue;
				}

				// SET
				if (p.Type.TryIfSet(out var setValType))
				{
					var addedVar = $"__{p.Base.Name}_added";
					var removedVar = $"__{p.Base.Name}_removed";

					sb.AppendLine($"\t\tvar {addedVar} = new List<{setValType}>();");
					sb.AppendLine($"\t\tvar {removedVar} = new List<{setValType}>();");

					sb.AppendLine($"\t\tif (this.{p.Base.Name}ToSet != null)");
					sb.AppendLine("\t\t{");
					sb.AppendLine($"\t\t\tforeach (var v in this.{p.Base.Name}ToSet)");
					sb.AppendLine("\t\t\t{");
					sb.AppendLine($"\t\t\t\tif ({name}.{p.Base.Name} == null || !{name}.{p.Base.Name}.Contains(v)) {addedVar}.Add(v);");
					sb.AppendLine("\t\t\t}");
					sb.AppendLine("\t\t}");

					sb.AppendLine($"\t\tif (this.{p.Base.Name}ToRemove != null && {name}.{p.Base.Name} != null)");
					sb.AppendLine("\t\t{");
					sb.AppendLine($"\t\t\tforeach (var v in this.{p.Base.Name}ToRemove)");
					sb.AppendLine("\t\t\t{");
					sb.AppendLine($"\t\t\t\tif ({name}.{p.Base.Name}.Contains(v)) {removedVar}.Add(v);");
					sb.AppendLine("\t\t\t}");
					sb.AppendLine("\t\t}");

					// updater-in-set
					if (setValType.TryIfUpdater(out var setValUpdater))
					{
						sb.AppendLine($"\t\tif (this.{p.Base.Name}Updates != null)");
						sb.AppendLine("\t\t{");
						sb.AppendLine($"\t\t\tforeach (var upd in this.{p.Base.Name}Updates)");
						sb.AppendLine("\t\t\t{");
						sb.AppendLine($"\t\t\t\tif (upd.TryCreate(out var created))");
						sb.AppendLine("\t\t\t\t{");
						sb.AppendLine($"\t\t\t\t\tif ({name}.{p.Base.Name} == null || !{name}.{p.Base.Name}.Contains(created)) {addedVar}.Add(created);");
						sb.AppendLine("\t\t\t\t}");
						sb.AppendLine("\t\t\t}");
						sb.AppendLine("\t\t}");
					}

					ctorArgs.Add($"{addedVar}.ToArray()");
					ctorArgs.Add($"{removedVar}.ToArray()");

					sb.AppendLine();
					continue;
				}

				// REGULAR (value or nested updater)
				// For immutable Changes, create local hasChanged and prev variables
				var hasVar = $"__{p.Base.Name}_hasChanged";
				var prevVar = $"__{p.Base.Name}_prev";
				sb.AppendLine($"\t\tvar {hasVar} = false;");
				sb.AppendLine($"\t\tvar {prevVar} = default({p.Type});");

				if (p.Type.TryIfUpdater(out var nestedUpd))
				{
					if (nestedUpd.IsStruct)
					{
						sb.AppendLine($"\t\tif (this.{p.Base.Name}.HasValue)");

					}
					else
					{
						sb.AppendLine($"\t\tif (this.{p.Base.Name} != null)");
					}

					sb.AppendLine("\t\t{");

					if (nestedUpd.IsStruct)
					{
						sb.AppendLine($"\t\t\tif (this.{p.Base.Name}.Value.TryCreate(out var __created_{p.Base.Name}))");
					}
					else
					{
						sb.AppendLine($"\t\t\tif (this.{p.Base.Name}.TryCreate(out var __created_{p.Base.Name}))");
					}

					sb.AppendLine("\t\t\t{");

					sb.AppendLine($"\t\t\t\tif (!EqualityComparer<{p.Type}>.Default.Equals({name}.{p.Base.Name}, __created_{p.Base.Name}))");

					sb.AppendLine("\t\t\t\t{");
					sb.AppendLine($"\t\t\t\t\t{hasVar} = true;");

					sb.AppendLine($"\t\t\t\t\t{prevVar} = {name}.{p.Base.Name};");

					sb.AppendLine("\t\t\t\t}");
					sb.AppendLine("\t\t\t}");
					sb.AppendLine("\t\t}");
				}
				else
				{
					sb.AppendLine($"\t\tif (this.{p.Base.Name}IsSet)");
					sb.AppendLine("\t\t{");
					sb.AppendLine($"\t\t\tif (!EqualityComparer<{p.Type}>.Default.Equals({name}.{p.Base.Name}, this.{p.Base.Name}))");
					sb.AppendLine("\t\t\t{");
					sb.AppendLine($"\t\t\t\t{hasVar} = true;");
					sb.AppendLine($"\t\t\t\t{prevVar} = {name}.{p.Base.Name};");
					sb.AppendLine("\t\t\t}");
					sb.AppendLine("\t\t}");
				}

				ctorArgs.Add(hasVar);
				ctorArgs.Add(prevVar);

				sb.AppendLine();
			}

			// Construct and return an immutable Changes record via positional ctor
			var ctorArgList = string.Join(", ", ctorArgs);
			sb.AppendLine($"\t\treturn new {changesName}({ctorArgList});");
			sb.AppendLine("    }");
			sb.AppendLine();
		}

		private static void EmitApplyMethod(StringBuilder sb, ClassOrStructureToUse t)
		{
			var type = t.Base;
			var name = char.ToLowerInvariant(type.Name[0]) + type.Name.Substring(1);
			var changesName = t.ChangesName;

			// signature
			if (type.IsValueType && type.IsReadOnly)
			{
				sb.AppendLine($"    public {type.Name} WithUpdate({type.Name} {name}, out {changesName} changes)");
			}
			else if (type.IsValueType)
			{
				sb.AppendLine($"    public void AppendUpdate(ref {type.Name} {name}, out {changesName} changes)");
			}
			else
			{
				sb.AppendLine($"    public void AppendUpdate({type.Name} {name}, out {changesName} changes)");
			}

			sb.AppendLine("    {");

			// compute changes using newly added Changes(...) method
			if (type.IsValueType)
				sb.AppendLine($"\t\tchanges = Changes(in {name});");
			else
				sb.AppendLine($"\t\tchanges = Changes({name});");

			sb.AppendLine();

			// Now apply updates (mutating target)
			foreach (var p in t.Properties)
			{
				// DICTIONARY
				if (p.Type.TryIfDictionary(out var dictKeyType, out var dictValueType))
				{
					// apply ToSet
					sb.AppendLine($"\t\tif (this.{p.Base.Name}ToSet != null)");
					sb.AppendLine("\t\t{");
					

					if (dictValueType.TryIfUpdater(out var dictValUpdater))
					{
						//sb.AppendLine($"\t\t\tif ({name}.{p.Base.Name} == null) {name}.{p.Base.Name} = new Dictionary<{dictKeyType}, {dictValUpdater}>();");
						sb.AppendLine($"\t\t\tforeach (var kv in this.{p.Base.Name}ToSet)");
						sb.AppendLine("\t\t\t{");
						// set dictkey on updater in case it's needed
						if (dictValUpdater.DictKeyProp is not null)
							sb.AppendLine($"\t\t\t\tkv.Value.Set{dictValUpdater.DictKeyProp.Base.Name}(kv.Key);");
						sb.AppendLine($"\t\t\t\tif (kv.Value.TryCreate(out var created))");
						sb.AppendLine($"\t\t\t\t\t{name}.{p.Base.Name}[kv.Key] = created;");
						sb.AppendLine("\t\t\t}");
					}
					else
					{
						//sb.AppendLine($"\t\t\tif ({name}.{p.Base.Name} == null) {name}.{p.Base.Name} = new Dictionary<{dictKeyType}, {dictValueType}>();");
						sb.AppendLine($"\t\t\tforeach (var kv in this.{p.Base.Name}ToSet)");
						sb.AppendLine($"\t\t\t\t{name}.{p.Base.Name}[kv.Key] = kv.Value;");
					}
					sb.AppendLine("\t\t}");

					// apply removals
					sb.AppendLine($"\t\tif (this.{p.Base.Name}ToRemove != null && {name}.{p.Base.Name} != null)");
					sb.AppendLine("\t\t{");
					sb.AppendLine($"\t\t\tforeach (var k in this.{p.Base.Name}ToRemove) {name}.{p.Base.Name}.Remove(k);");
					sb.AppendLine("\t\t}");
					sb.AppendLine();
					continue;
				}

				// SET
				if (p.Type.TryIfSet(out var setValueType))
				{
					// ToSet union
					sb.AppendLine($"\t\tif (this.{p.Base.Name}ToSet != null)");
					sb.AppendLine("\t\t{");
					//sb.AppendLine($"\t\t\tif ({name}.{p.Base.Name} == null) {name}.{p.Base.Name} = new HashSet<{setValueType}>();");
					sb.AppendLine($"\t\t\t{name}.{p.Base.Name}.UnionWith(this.{p.Base.Name}ToSet);");
					sb.AppendLine("\t\t}");

					// ToRemove except
					sb.AppendLine($"\t\tif (this.{p.Base.Name}ToRemove != null && {name}.{p.Base.Name} != null)");
					sb.AppendLine("\t\t{");
					sb.AppendLine($"\t\t\t{name}.{p.Base.Name}.ExceptWith(this.{p.Base.Name}ToRemove);");
					sb.AppendLine("\t\t}");

					// Updates (updater-in-set)
					if (setValueType.TryIfUpdater(out var setValUpdater))
					{
						sb.AppendLine($"\t\tif (this.{p.Base.Name}Updates != null)");
						sb.AppendLine("\t\t{");
						//sb.AppendLine($"\t\t\tif ({name}.{p.Base.Name} == null) {name}.{p.Base.Name} = new HashSet<{setValueType}>();");
						sb.AppendLine($"\t\t\tforeach (var upd in this.{p.Base.Name}Updates)");
						sb.AppendLine("\t\t\t{");
						sb.AppendLine($"\t\t\t\tif (upd.TryCreate(out var created)) {name}.{p.Base.Name}.Add(created);");
						sb.AppendLine("\t\t\t}");
						sb.AppendLine("\t\t}");
					}

					sb.AppendLine();
					continue;
				}

				// REGULAR
				sb.AppendLine($"\t\tif (this.{p.Base.Name}IsSet)");
				sb.AppendLine("\t\t{");
				if (p.Type.TryIfUpdater(out var nested))
				{
					if (p.Type.IsValue)
					{
						sb.AppendLine($"\t\t\tif (this.{p.Base.Name}.Value.TryCreate(out var created{p.Base.Name}))");
						sb.AppendLine($"\t\t\t\t{name}.{p.Base.Name} = created{p.Base.Name};");
					}
					else
					{
						sb.AppendLine($"\t\t\tif (this.{p.Base.Name}.TryCreate(out var created{p.Base.Name}))");
						sb.AppendLine($"\t\t\t\t{name}.{p.Base.Name} = created{p.Base.Name};");
					}
				}
				else
				{
					sb.AppendLine($"\t\t\t{name}.{p.Base.Name} = this.{p.Base.Name};");
				}
				sb.AppendLine("\t\t}");
				sb.AppendLine();
			}

			// For readonly structs return the new value
			if (t.IsStruct && t.Base.IsReadOnly)
			{
				sb.AppendLine($"\t\treturn {name};");
			}

			sb.AppendLine("    }");
			sb.AppendLine();
		}
	}
}
